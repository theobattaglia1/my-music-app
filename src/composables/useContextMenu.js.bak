// src/composables/useContextMenu.js

import { inject } from 'vue'
import { useToastStore } from '@/store/toast'
import { useMusicStore } from '@/store/music'
import { invoke } from '@tauri-apps/api/tauri'
import { writeText } from '@tauri-apps/api/clipboard'

// Global references
let contextMenuInstance = null
let metadataEditorInstance = null

export function registerContextMenu(instance) {
  contextMenuInstance = instance
}

export function registerMetadataEditor(instance) {
  metadataEditorInstance = instance
}

export function useContextMenu() {
  const toast = useToastStore()
  const musicStore = useMusicStore()
  
  // Try to get the metadata editor (unified modal) from injection
  const metadataEditor = inject('metadataEditor', null)

  // Handler for edit metadata
  const handleEditMetadata = (items, type) => {
    console.log('ðŸŽ¯ handleEditMetadata called with:', { items, type })
    
    // Use the injected metadata editor if available, otherwise use the global instance
    const editor = metadataEditor || metadataEditorInstance
    
    if (editor) {
      // The unified modal expects a different API
      editor.show({
        mode: 'edit',
        type: type,
        items: Array.isArray(items) ? items : [items]
      })
    } else {
      console.error('No metadata editor instance available')
      toast.push({ msg: 'Metadata editor not available', type: 'error' })
    }
  }

  // Handler for playing songs/playlists/artists
  const handlePlay = (item) => {
    musicStore.playSong(item.id)
  }

  const handlePlayPlaylist = (playlist) => {
    musicStore.playPlaylist(playlist.id)
  }

  const handlePlayArtist = async (artist) => {
    try {
      const songs = await invoke('get_artist_songs', { artist_id: artist.id })
      if (songs && songs.length > 0) {
        musicStore.playQueue(songs)
      } else {
        toast.push({ msg: 'No songs found for this artist', type: 'info' })
      }
    } catch (error) {
      console.error('Error playing artist:', error)
      toast.push({ msg: 'Failed to play artist', type: 'error' })
    }
  }

  // Handler for shuffling
  const handleShufflePlaylist = (playlist) => {
    musicStore.shufflePlaylist(playlist.id)
  }

  const handleShuffleArtist = async (artist) => {
    try {
      const songs = await invoke('get_artist_songs', { artist_id: artist.id })
      if (songs && songs.length > 0) {
        const shuffled = [...songs].sort(() => Math.random() - 0.5)
        musicStore.playQueue(shuffled)
      } else {
        toast.push({ msg: 'No songs found for this artist', type: 'info' })
      }
    } catch (error) {
      console.error('Error shuffling artist:', error)
      toast.push({ msg: 'Failed to shuffle artist', type: 'error' })
    }
  }

  // Handler for adding to queue
  const handleAddToQueue = (items) => {
    const songs = Array.isArray(items) ? items : [items]
    songs.forEach(song => musicStore.addToQueue(song))
    toast.push({ 
      msg: `Added ${songs.length} song${songs.length > 1 ? 's' : ''} to queue`, 
      type: 'success' 
    })
  }

  // Handler for adding to playlist
  const handleAddToPlaylist = async (playlistId, items) => {
    try {
      const songIds = items.map(item => item.id)
      await invoke('add_songs_to_playlist', {
        playlist_id: playlistId,
        song_ids: songIds
      })
      toast.push({ 
        msg: `Added ${items.length} song${items.length > 1 ? 's' : ''} to playlist`, 
        type: 'success' 
      })
      // Refresh library to update playlist
      await musicStore.refreshLibrary()
    } catch (error) {
      console.error('Error adding to playlist:', error)
      toast.push({ msg: 'Failed to add to playlist', type: 'error' })
    }
  }

  // Handler for creating new playlist with songs
  const handleCreateNewPlaylist = (items) => {
    // Use the unified modal to create a new playlist
    const editor = metadataEditor || metadataEditorInstance
    
    if (editor) {
      // Store the songs temporarily so we can add them after playlist creation
      window._pendingSongsForNewPlaylist = items
      
      editor.show({
        mode: 'create',
        type: 'playlist',
        tab: 'playlist'
      })
      
      toast.push({ 
        msg: 'Create a playlist, then the selected songs will be added', 
        type: 'info' 
      })
    } else {
      console.error('No metadata editor instance available')
      toast.push({ msg: 'Cannot create playlist', type: 'error' })
    }
  }

  // Handler for copying file path
  const handleCopyPath = async (item) => {
    try {
      if (item.file_path) {
        await writeText(item.file_path)
        toast.push({ msg: 'File path copied to clipboard', type: 'success' })
      } else {
        toast.push({ msg: 'No file path available', type: 'error' })
      }
    } catch (error) {
      console.error('Error copying path:', error)
      toast.push({ msg: 'Failed to copy file path', type: 'error' })
    }
  }

  // Handler for deleting items
  const handleDelete = async (items, type) => {
    const count = items.length
    const itemType = type === 'song' ? 'song' : type === 'playlist' ? 'playlist' : 'artist'
    const plural = count > 1 ? 's' : ''
    
    // Confirm deletion
    const confirmed = confirm(`Are you sure you want to delete ${count} ${itemType}${plural}?`)
    if (!confirmed) return
    
    try {
      for (const item of items) {
        if (type === 'song') {
          await invoke('delete_song', { song_id: item.id })
        } else if (type === 'playlist') {
          await invoke('delete_playlist', { playlist_id: item.id })
        } else if (type === 'artist') {
          await invoke('delete_artist', { artist_id: item.id })
        }
      }
      
      toast.push({ 
        msg: `Deleted ${count} ${itemType}${plural}`, 
        type: 'success' 
      })
      
      // Refresh library
      await musicStore.refreshLibrary()
    } catch (error) {
      console.error('Error deleting items:', error)
      toast.push({ msg: `Failed to delete ${itemType}${plural}`, type: 'error' })
    }
  }

  return {
    handleEditMetadata,
    handlePlay,
    handleAddToQueue,
    handlePlayPlaylist,
    handleShufflePlaylist,
    handlePlayArtist,
    handleShuffleArtist,
    handleAddToPlaylist,
    handleCreateNewPlaylist,
    handleCopyPath,
    handleDelete
  }
}